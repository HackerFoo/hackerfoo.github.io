<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Startle: support.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Startle
   </div>
   <div id="projectbrief">Useful and efficient algorithms and facilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">support.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generally useful functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;sys/mman.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">startle/types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">startle/macros.h</a>&quot;</code><br />
<code>#include &quot;startle/error.h&quot;</code><br />
<code>#include &quot;startle/log.h&quot;</code><br />
<code>#include &quot;startle/support.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a28ab213400077fee723d456d203e1afe"><td class="memItemLeft" align="right" valign="top"><a id="a28ab213400077fee723d456d203e1afe"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a28ab213400077fee723d456d203e1afe">median3</a> (<a class="el" href="structpair__t.html">pair_t</a> *array, unsigned int lo, unsigned int hi)</td></tr>
<tr class="memdesc:a28ab213400077fee723d456d203e1afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the median of an array. <br /></td></tr>
<tr class="separator:a28ab213400077fee723d456d203e1afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e650a99128141a67f1c034800b5df3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a12e650a99128141a67f1c034800b5df3">swap</a> (<a class="el" href="structpair__t.html">pair_t</a> *x, <a class="el" href="structpair__t.html">pair_t</a> *y)</td></tr>
<tr class="memdesc:a12e650a99128141a67f1c034800b5df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two pairs.  <a href="#a12e650a99128141a67f1c034800b5df3">More...</a><br /></td></tr>
<tr class="separator:a12e650a99128141a67f1c034800b5df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3790f31522539dd0061a88d89676aa2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a3790f31522539dd0061a88d89676aa2a">print_pairs</a> (<a class="el" href="structpair__t.html">pair_t</a> *array, size_t len)</td></tr>
<tr class="memdesc:a3790f31522539dd0061a88d89676aa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the pairs in an array.  <a href="#a3790f31522539dd0061a88d89676aa2a">More...</a><br /></td></tr>
<tr class="separator:a3790f31522539dd0061a88d89676aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b66a72896e2da25bc2aa86a477e8347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a2b66a72896e2da25bc2aa86a477e8347">print_string_pairs</a> (<a class="el" href="structpair__t.html">pair_t</a> *array, size_t len)</td></tr>
<tr class="memdesc:a2b66a72896e2da25bc2aa86a477e8347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the pairs in an array, where the first item is a string.  <a href="#a2b66a72896e2da25bc2aa86a477e8347">More...</a><br /></td></tr>
<tr class="separator:a2b66a72896e2da25bc2aa86a477e8347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed75b3aafd0856fd8d1c9050617a8696"><td class="memItemLeft" align="right" valign="top"><a id="aed75b3aafd0856fd8d1c9050617a8696"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (sort)</td></tr>
<tr class="separator:aed75b3aafd0856fd8d1c9050617a8696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c396b19ac26074dc676736745af4ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#ae2c396b19ac26074dc676736745af4ff">quicksort</a> (<a class="el" href="structpair__t.html">pair_t</a> *array, unsigned int size)</td></tr>
<tr class="memdesc:ae2c396b19ac26074dc676736745af4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Quicksort algorithm to sort an array of pairs by the first element.  <a href="#ae2c396b19ac26074dc676736745af4ff">More...</a><br /></td></tr>
<tr class="separator:ae2c396b19ac26074dc676736745af4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428a9512b2b2bc6f7191f29eb2364ef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a428a9512b2b2bc6f7191f29eb2364ef1">find</a> (<a class="el" href="structpair__t.html">pair_t</a> *array, size_t size, uintptr_t key)</td></tr>
<tr class="memdesc:a428a9512b2b2bc6f7191f29eb2364ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a pair with matching key in a sorted array of pairs using binary search.  <a href="#a428a9512b2b2bc6f7191f29eb2364ef1">More...</a><br /></td></tr>
<tr class="separator:a428a9512b2b2bc6f7191f29eb2364ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeadd43b19f08a452756eeb0db41740f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#aeeadd43b19f08a452756eeb0db41740f">find_last</a> (<a class="el" href="structpair__t.html">pair_t</a> *array, size_t size, uintptr_t key)</td></tr>
<tr class="memdesc:aeeadd43b19f08a452756eeb0db41740f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>find</code>, but find the last match.  <a href="#aeeadd43b19f08a452756eeb0db41740f">More...</a><br /></td></tr>
<tr class="separator:aeeadd43b19f08a452756eeb0db41740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d824255d64571d1dee41e5f8b8b0e9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a5d824255d64571d1dee41e5f8b8b0e9c">find_last_string</a> (<a class="el" href="structpair__t.html">pair_t</a> *array, size_t size, const char *key)</td></tr>
<tr class="memdesc:a5d824255d64571d1dee41e5f8b8b0e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>find</code>, but find the last match, with a string key.  <a href="#a5d824255d64571d1dee41e5f8b8b0e9c">More...</a><br /></td></tr>
<tr class="separator:a5d824255d64571d1dee41e5f8b8b0e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068231848fb1df5ef1a36bd402c7afd0"><td class="memItemLeft" align="right" valign="top"><a id="a068231848fb1df5ef1a36bd402c7afd0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a068231848fb1df5ef1a36bd402c7afd0">segcmp</a> (const char *str, <a class="el" href="structseg__t.html">seg_t</a> seg)</td></tr>
<tr class="memdesc:a068231848fb1df5ef1a36bd402c7afd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a string to a <a class="el" href="structseg__t.html" title="A string segment. ">seg_t</a>. <br /></td></tr>
<tr class="separator:a068231848fb1df5ef1a36bd402c7afd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8948918be5534381bdbcea4ed8e461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a0f8948918be5534381bdbcea4ed8e461">find_last_seg</a> (<a class="el" href="structpair__t.html">pair_t</a> *array, size_t size, <a class="el" href="structseg__t.html">seg_t</a> key)</td></tr>
<tr class="memdesc:a0f8948918be5534381bdbcea4ed8e461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>find</code>, but find the last match, with a string segment key.  <a href="#a0f8948918be5534381bdbcea4ed8e461">More...</a><br /></td></tr>
<tr class="separator:a0f8948918be5534381bdbcea4ed8e461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487930341c629106ecda3c396854415a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a487930341c629106ecda3c396854415a">seg_end</a> (<a class="el" href="structseg__t.html">seg_t</a> seg)</td></tr>
<tr class="memdesc:a487930341c629106ecda3c396854415a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer after the end of the string segment.  <a href="#a487930341c629106ecda3c396854415a">More...</a><br /></td></tr>
<tr class="separator:a487930341c629106ecda3c396854415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659a103abbf0f0ae8cd6c549d325a09b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a659a103abbf0f0ae8cd6c549d325a09b">seg_read</a> (<a class="el" href="structseg__t.html">seg_t</a> seg, char *str, size_t size)</td></tr>
<tr class="memdesc:a659a103abbf0f0ae8cd6c549d325a09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string segment into a character array, as a zero terminated C string.  <a href="#a659a103abbf0f0ae8cd6c549d325a09b">More...</a><br /></td></tr>
<tr class="separator:a659a103abbf0f0ae8cd6c549d325a09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1ce49916be7da057970e10468d9a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structseg__t.html">seg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a3e1ce49916be7da057970e10468d9a67">seg_after</a> (<a class="el" href="structseg__t.html">seg_t</a> s, char c)</td></tr>
<tr class="memdesc:a3e1ce49916be7da057970e10468d9a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the segment after the first character matching <code>c</code>.  <a href="#a3e1ce49916be7da057970e10468d9a67">More...</a><br /></td></tr>
<tr class="separator:a3e1ce49916be7da057970e10468d9a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b11124427d92933d52f72e6e95159d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a33b11124427d92933d52f72e6e95159d">lookup</a> (void *table, size_t width, size_t rows, <a class="el" href="structseg__t.html">seg_t</a> key_seg)</td></tr>
<tr class="memdesc:a33b11124427d92933d52f72e6e95159d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the string segment key in a sorted table.  <a href="#a33b11124427d92933d52f72e6e95159d">More...</a><br /></td></tr>
<tr class="separator:a33b11124427d92933d52f72e6e95159d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cada1c1e885ab52e30ee55641d33856"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a2cada1c1e885ab52e30ee55641d33856">lookup_linear</a> (void *table, size_t width, size_t rows, <a class="el" href="structseg__t.html">seg_t</a> key_seg)</td></tr>
<tr class="memdesc:a2cada1c1e885ab52e30ee55641d33856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the string segment key in an unsorted table.  <a href="#a2cada1c1e885ab52e30ee55641d33856">More...</a><br /></td></tr>
<tr class="separator:a2cada1c1e885ab52e30ee55641d33856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe2f841e11ce9bcce5366507e27b01d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a1fe2f841e11ce9bcce5366507e27b01d">mmap_file</a> (struct mmfile *f)</td></tr>
<tr class="memdesc:a1fe2f841e11ce9bcce5366507e27b01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a file to memory Use <code>path</code> and <code>read_only</code> from the <code>mmfile</code> referenced by <code>f</code>.  <a href="#a1fe2f841e11ce9bcce5366507e27b01d">More...</a><br /></td></tr>
<tr class="separator:a1fe2f841e11ce9bcce5366507e27b01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc20baf5f25eaddef189652749b1de5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#acbc20baf5f25eaddef189652749b1de5">munmap_file</a> (struct mmfile *f)</td></tr>
<tr class="memdesc:acbc20baf5f25eaddef189652749b1de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-map a file from memory using the data set by <code>mmap_file</code>.  <a href="#acbc20baf5f25eaddef189652749b1de5">More...</a><br /></td></tr>
<tr class="separator:acbc20baf5f25eaddef189652749b1de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b126ce87d752ae9710861d1c0d1a34"><td class="memItemLeft" align="right" valign="top"><a id="a11b126ce87d752ae9710861d1c0d1a34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (<a class="el" href="support_8c.html#a1fe2f841e11ce9bcce5366507e27b01d">mmap_file</a>)</td></tr>
<tr class="separator:a11b126ce87d752ae9710861d1c0d1a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcaebdc377f33a61e9b6271942427b9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#aafcaebdc377f33a61e9b6271942427b9">line_number</a> (const char *s, const char *e)</td></tr>
<tr class="memdesc:aafcaebdc377f33a61e9b6271942427b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count lines to reach <code>e</code> starting from <code>s</code>.  <a href="#aafcaebdc377f33a61e9b6271942427b9">More...</a><br /></td></tr>
<tr class="separator:aafcaebdc377f33a61e9b6271942427b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407b4acfec2e43e5c4add68d189f2d16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a407b4acfec2e43e5c4add68d189f2d16">find_line</a> (const char *x, const char **s, size_t *size)</td></tr>
<tr class="memdesc:a407b4acfec2e43e5c4add68d189f2d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a line containing the address.  <a href="#a407b4acfec2e43e5c4add68d189f2d16">More...</a><br /></td></tr>
<tr class="separator:a407b4acfec2e43e5c4add68d189f2d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29c43f6dc11b84ebbacedf37d00138d"><td class="memItemLeft" align="right" valign="top"><a id="ab29c43f6dc11b84ebbacedf37d00138d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#ab29c43f6dc11b84ebbacedf37d00138d">int_log2</a> (unsigned int x)</td></tr>
<tr class="memdesc:ab29c43f6dc11b84ebbacedf37d00138d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer log2. <br /></td></tr>
<tr class="separator:ab29c43f6dc11b84ebbacedf37d00138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2344ade960310a44cdd8de9430b4d098"><td class="memItemLeft" align="right" valign="top"><a id="a2344ade960310a44cdd8de9430b4d098"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a2344ade960310a44cdd8de9430b4d098">int_log2l</a> (long unsigned int x)</td></tr>
<tr class="memdesc:a2344ade960310a44cdd8de9430b4d098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Long integer log2. <br /></td></tr>
<tr class="separator:a2344ade960310a44cdd8de9430b4d098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0338032b19251449534cc99a641f14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#adb0338032b19251449534cc99a641f14">set_insert</a> (uintptr_t x, uintptr_t *set, size_t size)</td></tr>
<tr class="memdesc:adb0338032b19251449534cc99a641f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert into a set.  <a href="#adb0338032b19251449534cc99a641f14">More...</a><br /></td></tr>
<tr class="separator:adb0338032b19251449534cc99a641f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca529206f82d21f73bf3a882655c8c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a0ca529206f82d21f73bf3a882655c8c9">set_member</a> (uintptr_t x, uintptr_t *set, size_t size)</td></tr>
<tr class="memdesc:a0ca529206f82d21f73bf3a882655c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if an item is in the set.  <a href="#a0ca529206f82d21f73bf3a882655c8c9">More...</a><br /></td></tr>
<tr class="separator:a0ca529206f82d21f73bf3a882655c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62afae7fd3b702698a650f120bad0ebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a62afae7fd3b702698a650f120bad0ebb">set_remove</a> (uintptr_t x, uintptr_t *set, size_t size)</td></tr>
<tr class="memdesc:a62afae7fd3b702698a650f120bad0ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from the set.  <a href="#a62afae7fd3b702698a650f120bad0ebb">More...</a><br /></td></tr>
<tr class="separator:a62afae7fd3b702698a650f120bad0ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c96032cb0d85748bcd7cc90dca187f"><td class="memItemLeft" align="right" valign="top"><a id="a87c96032cb0d85748bcd7cc90dca187f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (set)</td></tr>
<tr class="separator:a87c96032cb0d85748bcd7cc90dca187f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc78fead79184569fc5f1c7ba499137"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#abbc78fead79184569fc5f1c7ba499137">swap_ptrs</a> (void **x, void **y)</td></tr>
<tr class="memdesc:abbc78fead79184569fc5f1c7ba499137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two pointers.  <a href="#abbc78fead79184569fc5f1c7ba499137">More...</a><br /></td></tr>
<tr class="separator:abbc78fead79184569fc5f1c7ba499137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d46fd27b878b61741f26f8f44ef0a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#ae8d46fd27b878b61741f26f8f44ef0a0">reverse_ptrs</a> (void **a, size_t n)</td></tr>
<tr class="memdesc:ae8d46fd27b878b61741f26f8f44ef0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse an array of pointers.  <a href="#ae8d46fd27b878b61741f26f8f44ef0a0">More...</a><br /></td></tr>
<tr class="separator:ae8d46fd27b878b61741f26f8f44ef0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666e4046fc303f72e60536d0790480aa"><td class="memItemLeft" align="right" valign="top"><a id="a666e4046fc303f72e60536d0790480aa"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>arguments</b> (int argc, char **argv)</td></tr>
<tr class="separator:a666e4046fc303f72e60536d0790480aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5eb58d7196ed07a4478c7da8941bba"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="support_8c.html#a0f5eb58d7196ed07a4478c7da8941bba">nonzero_hash</a> (const char *str, size_t len)</td></tr>
<tr class="memdesc:a0f5eb58d7196ed07a4478c7da8941bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash the string to a non-zero number.  <a href="#a0f5eb58d7196ed07a4478c7da8941bba">More...</a><br /></td></tr>
<tr class="separator:a0f5eb58d7196ed07a4478c7da8941bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generally useful functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a428a9512b2b2bc6f7191f29eb2364ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428a9512b2b2bc6f7191f29eb2364ef1">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpair__t.html">pair_t</a>* find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a pair with matching key in a sorted array of pairs using binary search. </p>
<p>O(log n) time. </p>

</div>
</div>
<a id="aeeadd43b19f08a452756eeb0db41740f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeadd43b19f08a452756eeb0db41740f">&#9670;&nbsp;</a></span>find_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpair__t.html">pair_t</a>* find_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>find</code>, but find the last match. </p>
<p>O(log n) time. </p>

</div>
</div>
<a id="a0f8948918be5534381bdbcea4ed8e461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8948918be5534381bdbcea4ed8e461">&#9670;&nbsp;</a></span>find_last_seg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpair__t.html">pair_t</a>* find_last_seg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structseg__t.html">seg_t</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>find</code>, but find the last match, with a string segment key. </p>
<p>O(log n) time. </p>

</div>
</div>
<a id="a5d824255d64571d1dee41e5f8b8b0e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d824255d64571d1dee41e5f8b8b0e9c">&#9670;&nbsp;</a></span>find_last_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpair__t.html">pair_t</a>* find_last_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>find</code>, but find the last match, with a string key. </p>
<p>O(log n) time. </p>

</div>
</div>
<a id="a407b4acfec2e43e5c4add68d189f2d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407b4acfec2e43e5c4add68d189f2d16">&#9670;&nbsp;</a></span>find_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool find_line </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a line containing the address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>address into a line of text  [in,out] start of text/line  [in,out] size of text/line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the line was found </dd></dl>

</div>
</div>
<a id="aafcaebdc377f33a61e9b6271942427b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcaebdc377f33a61e9b6271942427b9">&#9670;&nbsp;</a></span>line_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t line_number </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count lines to reach <code>e</code> starting from <code>s</code>. </p>

</div>
</div>
<a id="a33b11124427d92933d52f72e6e95159d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b11124427d92933d52f72e6e95159d">&#9670;&nbsp;</a></span>lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lookup </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structseg__t.html">seg_t</a>&#160;</td>
          <td class="paramname"><em>key_seg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the string segment key in a sorted table. </p>
<p>Each row starts with a string pointer key. Binary search, O(log n) time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>the table </td></tr>
    <tr><td class="paramname">width</td><td>width of each row in bytes </td></tr>
    <tr><td class="paramname">rows</td><td>the number of rows </td></tr>
    <tr><td class="paramname">key_seg</td><td>the key string segment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cada1c1e885ab52e30ee55641d33856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cada1c1e885ab52e30ee55641d33856">&#9670;&nbsp;</a></span>lookup_linear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lookup_linear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structseg__t.html">seg_t</a>&#160;</td>
          <td class="paramname"><em>key_seg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the string segment key in an unsorted table. </p>
<p>Each row starts with a string pointer key. Linear search, O(n) time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>the table </td></tr>
    <tr><td class="paramname">width</td><td>width of each row in bytes </td></tr>
    <tr><td class="paramname">rows</td><td>the number of rows </td></tr>
    <tr><td class="paramname">key_seg</td><td>the key string segment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fe2f841e11ce9bcce5366507e27b01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe2f841e11ce9bcce5366507e27b01d">&#9670;&nbsp;</a></span>mmap_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mmap_file </td>
          <td>(</td>
          <td class="paramtype">struct mmfile *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a file to memory Use <code>path</code> and <code>read_only</code> from the <code>mmfile</code> referenced by <code>f</code>. </p>
<p>Sets <code>data</code> and <code>size</code>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, otherwise <code>false</code>. <div class="fragment"><div class="line">  <span class="keyword">struct </span>mmfile f = {</div><div class="line">    .path = <span class="stringliteral">&quot;eval.c&quot;</span>,</div><div class="line">    .read_only = <span class="keyword">true</span></div><div class="line">  };</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="support_8c.html#a1fe2f841e11ce9bcce5366507e27b01d">mmap_file</a>(&amp;f)) <span class="keywordflow">return</span> -1;</div><div class="line">  <span class="keywordtype">char</span> *c = f.data + 3;</div><div class="line">  <span class="keywordtype">size_t</span> n = f.size;</div><div class="line">  <span class="keywordflow">while</span>(n--) {</div><div class="line">    putchar(*c);</div><div class="line">    <span class="keywordflow">if</span>(*c == <span class="charliteral">&#39;\n&#39;</span>) <span class="keywordflow">break</span>;</div><div class="line">    c++;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="support_8c.html#acbc20baf5f25eaddef189652749b1de5">munmap_file</a>(&amp;f)) <span class="keywordflow">return</span> -1;</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="acbc20baf5f25eaddef189652749b1de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc20baf5f25eaddef189652749b1de5">&#9670;&nbsp;</a></span>munmap_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool munmap_file </td>
          <td>(</td>
          <td class="paramtype">struct mmfile *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Un-map a file from memory using the data set by <code>mmap_file</code>. </p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>mmfile f = {</div><div class="line">    .path = <span class="stringliteral">&quot;eval.c&quot;</span>,</div><div class="line">    .read_only = <span class="keyword">true</span></div><div class="line">  };</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="support_8c.html#a1fe2f841e11ce9bcce5366507e27b01d">mmap_file</a>(&amp;f)) <span class="keywordflow">return</span> -1;</div><div class="line">  <span class="keywordtype">char</span> *c = f.data + 3;</div><div class="line">  <span class="keywordtype">size_t</span> n = f.size;</div><div class="line">  <span class="keywordflow">while</span>(n--) {</div><div class="line">    putchar(*c);</div><div class="line">    <span class="keywordflow">if</span>(*c == <span class="charliteral">&#39;\n&#39;</span>) <span class="keywordflow">break</span>;</div><div class="line">    c++;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="support_8c.html#acbc20baf5f25eaddef189652749b1de5">munmap_file</a>(&amp;f)) <span class="keywordflow">return</span> -1;</div></div><!-- fragment -->
</div>
</div>
<a id="a0f5eb58d7196ed07a4478c7da8941bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5eb58d7196ed07a4478c7da8941bba">&#9670;&nbsp;</a></span>nonzero_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t nonzero_hash </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash the string to a non-zero number. </p>

</div>
</div>
<a id="a3790f31522539dd0061a88d89676aa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3790f31522539dd0061a88d89676aa2a">&#9670;&nbsp;</a></span>print_pairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_pairs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the pairs in an array. </p>

</div>
</div>
<a id="a2b66a72896e2da25bc2aa86a477e8347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b66a72896e2da25bc2aa86a477e8347">&#9670;&nbsp;</a></span>print_string_pairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_string_pairs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the pairs in an array, where the first item is a string. </p>

</div>
</div>
<a id="ae2c396b19ac26074dc676736745af4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c396b19ac26074dc676736745af4ff">&#9670;&nbsp;</a></span>quicksort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quicksort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Quicksort algorithm to sort an array of pairs by the first element. </p>
<div class="fragment"><div class="line">  <a class="code" href="structpair__t.html">pair_t</a> array[] = {{3, 0}, {7, 1}, {2, 2}, {4, 3}, {500, 4}, {0, 5}, {8, 6}, {4, 7}};</div><div class="line">  <a class="code" href="support_8c.html#ae2c396b19ac26074dc676736745af4ff">quicksort</a>(array, <a class="code" href="macros_8h.html#ad0e13d94164219be2d5bbd4d65e71d1e">LENGTH</a>(array));</div><div class="line">  uintptr_t last = array[0].first;</div><div class="line">  printf(<span class="stringliteral">&quot;{{%d, %d}&quot;</span>, (<span class="keywordtype">int</span>)array[0].first, (<span class="keywordtype">int</span>)array[0].second);</div><div class="line">  <a class="code" href="macros_8h.html#a432925f12441c5483c3c88954ef2b240">RANGEUP</a>(i, 1, <a class="code" href="macros_8h.html#ad0e13d94164219be2d5bbd4d65e71d1e">LENGTH</a>(array)) {</div><div class="line">    printf(<span class="stringliteral">&quot;, {%d, %d}&quot;</span>, (<span class="keywordtype">int</span>)array[i].first, (<span class="keywordtype">int</span>)array[i].second);</div><div class="line">    <span class="keywordflow">if</span>(array[i].first &lt; last) {</div><div class="line">      printf(<span class="stringliteral">&quot; &lt;- ERROR\n&quot;</span>);</div><div class="line">      <span class="keywordflow">return</span> -1;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  printf(<span class="stringliteral">&quot;}\n&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="structpair__t.html">pair_t</a> *p1 = <a class="code" href="support_8c.html#a428a9512b2b2bc6f7191f29eb2364ef1">find</a>(array, <a class="code" href="macros_8h.html#ad0e13d94164219be2d5bbd4d65e71d1e">LENGTH</a>(array), 7);</div><div class="line">  <span class="keywordtype">bool</span> r1 = p1 &amp;&amp; p1-&gt;second == 1;</div><div class="line">  printf(<span class="stringliteral">&quot;index find existing: %s\n&quot;</span>, r1 ? <span class="stringliteral">&quot;PASS&quot;</span> : <span class="stringliteral">&quot;FAIL&quot;</span>);</div><div class="line">  <span class="keywordtype">bool</span> r2 = !<a class="code" href="support_8c.html#a428a9512b2b2bc6f7191f29eb2364ef1">find</a>(array, <a class="code" href="macros_8h.html#ad0e13d94164219be2d5bbd4d65e71d1e">LENGTH</a>(array), 5);</div><div class="line">  printf(<span class="stringliteral">&quot;index find missing: %s\n&quot;</span>, r2 ? <span class="stringliteral">&quot;PASS&quot;</span> : <span class="stringliteral">&quot;FAIL&quot;</span>);</div></div><!-- fragment -->
</div>
</div>
<a id="ae8d46fd27b878b61741f26f8f44ef0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d46fd27b878b61741f26f8f44ef0a0">&#9670;&nbsp;</a></span>reverse_ptrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reverse_ptrs </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse an array of pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of pointers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e1ce49916be7da057970e10468d9a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1ce49916be7da057970e10468d9a67">&#9670;&nbsp;</a></span>seg_after()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseg__t.html">seg_t</a> seg_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseg__t.html">seg_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the segment after the first character matching <code>c</code>. </p>

</div>
</div>
<a id="a487930341c629106ecda3c396854415a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487930341c629106ecda3c396854415a">&#9670;&nbsp;</a></span>seg_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* seg_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseg__t.html">seg_t</a>&#160;</td>
          <td class="paramname"><em>seg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer after the end of the string segment. </p>

</div>
</div>
<a id="a659a103abbf0f0ae8cd6c549d325a09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659a103abbf0f0ae8cd6c549d325a09b">&#9670;&nbsp;</a></span>seg_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t seg_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseg__t.html">seg_t</a>&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string segment into a character array, as a zero terminated C string. </p>

</div>
</div>
<a id="adb0338032b19251449534cc99a641f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0338032b19251449534cc99a641f14">&#9670;&nbsp;</a></span>set_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_insert </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert into a set. </p>
<p>O(1) time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>to insert </td></tr>
    <tr><td class="paramname">set</td><td>the set </td></tr>
    <tr><td class="paramname">size</td><td>number of entries the set can hold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>x</code> was already in the set <div class="fragment"><div class="line">  uintptr_t <span class="keyword">set</span>[7] = {0};</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> size = <a class="code" href="macros_8h.html#ad0e13d94164219be2d5bbd4d65e71d1e">LENGTH</a>(<span class="keyword">set</span>);</div><div class="line">  uintptr_t data[] = {7, 8, 9, 14, 21, 28};</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, data) {</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="support_8c.html#adb0338032b19251449534cc99a641f14">set_insert</a>(data[i], <span class="keyword">set</span>, size)) <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, <span class="keyword">set</span>) {</div><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">set</span>[i]) printf(<span class="stringliteral">&quot;set[%d] = %d\n&quot;</span>, (<span class="keywordtype">int</span>)i, (<span class="keywordtype">int</span>)<span class="keyword">set</span>[i]);</div><div class="line">  }</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, data) {</div><div class="line">    <span class="keywordflow">if</span>(!<a class="code" href="support_8c.html#a0ca529206f82d21f73bf3a882655c8c9">set_member</a>(data[i], <span class="keyword">set</span>, size)) <span class="keywordflow">return</span> -2;</div><div class="line">  }</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, data) {</div><div class="line">    <span class="keywordflow">if</span>(!<a class="code" href="support_8c.html#a62afae7fd3b702698a650f120bad0ebb">set_remove</a>(data[i], <span class="keyword">set</span>, size)) <span class="keywordflow">return</span> -3;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="a0ca529206f82d21f73bf3a882655c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca529206f82d21f73bf3a882655c8c9">&#9670;&nbsp;</a></span>set_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_member </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return if an item is in the set. </p>
<p>O(1) time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>item to test </td></tr>
    <tr><td class="paramname">set</td><td>the set </td></tr>
    <tr><td class="paramname">size</td><td>number of entries the set can hold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>x</code> is in the set <div class="fragment"><div class="line">  uintptr_t <span class="keyword">set</span>[7] = {0};</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> size = <a class="code" href="macros_8h.html#ad0e13d94164219be2d5bbd4d65e71d1e">LENGTH</a>(<span class="keyword">set</span>);</div><div class="line">  uintptr_t data[] = {7, 8, 9, 14, 21, 28};</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, data) {</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="support_8c.html#adb0338032b19251449534cc99a641f14">set_insert</a>(data[i], <span class="keyword">set</span>, size)) <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, <span class="keyword">set</span>) {</div><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">set</span>[i]) printf(<span class="stringliteral">&quot;set[%d] = %d\n&quot;</span>, (<span class="keywordtype">int</span>)i, (<span class="keywordtype">int</span>)<span class="keyword">set</span>[i]);</div><div class="line">  }</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, data) {</div><div class="line">    <span class="keywordflow">if</span>(!<a class="code" href="support_8c.html#a0ca529206f82d21f73bf3a882655c8c9">set_member</a>(data[i], <span class="keyword">set</span>, size)) <span class="keywordflow">return</span> -2;</div><div class="line">  }</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, data) {</div><div class="line">    <span class="keywordflow">if</span>(!<a class="code" href="support_8c.html#a62afae7fd3b702698a650f120bad0ebb">set_remove</a>(data[i], <span class="keyword">set</span>, size)) <span class="keywordflow">return</span> -3;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="a62afae7fd3b702698a650f120bad0ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62afae7fd3b702698a650f120bad0ebb">&#9670;&nbsp;</a></span>set_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_remove </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an item from the set. </p>
<p>O(1) time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>to remove </td></tr>
    <tr><td class="paramname">set</td><td>the set </td></tr>
    <tr><td class="paramname">size</td><td>number of entries the set can hold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>x</code> was in the set <div class="fragment"><div class="line">  uintptr_t <span class="keyword">set</span>[7] = {0};</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> size = <a class="code" href="macros_8h.html#ad0e13d94164219be2d5bbd4d65e71d1e">LENGTH</a>(<span class="keyword">set</span>);</div><div class="line">  uintptr_t data[] = {7, 8, 9, 14, 21, 28};</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, data) {</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="support_8c.html#adb0338032b19251449534cc99a641f14">set_insert</a>(data[i], <span class="keyword">set</span>, size)) <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, <span class="keyword">set</span>) {</div><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">set</span>[i]) printf(<span class="stringliteral">&quot;set[%d] = %d\n&quot;</span>, (<span class="keywordtype">int</span>)i, (<span class="keywordtype">int</span>)<span class="keyword">set</span>[i]);</div><div class="line">  }</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, data) {</div><div class="line">    <span class="keywordflow">if</span>(!<a class="code" href="support_8c.html#a0ca529206f82d21f73bf3a882655c8c9">set_member</a>(data[i], <span class="keyword">set</span>, size)) <span class="keywordflow">return</span> -2;</div><div class="line">  }</div><div class="line">  <a class="code" href="macros_8h.html#a53141508c264fee8a2f3b3446c703763">FOREACH</a>(i, data) {</div><div class="line">    <span class="keywordflow">if</span>(!<a class="code" href="support_8c.html#a62afae7fd3b702698a650f120bad0ebb">set_remove</a>(data[i], <span class="keyword">set</span>, size)) <span class="keywordflow">return</span> -3;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="a12e650a99128141a67f1c034800b5df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e650a99128141a67f1c034800b5df3">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpair__t.html">pair_t</a> *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two pairs. </p>

</div>
</div>
<a id="abbc78fead79184569fc5f1c7ba499137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc78fead79184569fc5f1c7ba499137">&#9670;&nbsp;</a></span>swap_ptrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap_ptrs </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two pointers. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
